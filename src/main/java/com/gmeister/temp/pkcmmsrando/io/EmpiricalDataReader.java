package com.gmeister.temp.pkcmmsrando.io;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;

import com.gmeister.temp.pkcmmsrando.map.data.CollisionConstant;
import com.gmeister.temp.pkcmmsrando.map.data.CollisionPermission;
import com.gmeister.temp.pkcmmsrando.map.data.Flag;
import com.gmeister.temp.pkcmmsrando.map.data.MapBlocks.Direction;

/**
 * Reads select empirical data from files within this project. <br>
 * <br>
 * Reads data which has been inferred from gameplay or analysis of dissassembly
 * files, and stored in files generated by developers. This is particularly
 * effective for code or gameplay functions which are simple to interpret
 * externally. This analysis is often difficult or impossible to perform by
 * reading a disassembly or ROM.
 *
 * @author The_G_Meister
 *
 */
public class EmpiricalDataReader
{
	/**
	 * The directory to read files from.
	 */
	private File dir;
	
	public EmpiricalDataReader(File dir)
	{
		super();
		this.dir = dir;
	}
	
	public File getDir()
	{ return this.dir; }
	
	public void setDir(File dir)
	{ this.dir = dir; }
	
	public ArrayList<CollisionPermission> readCollisionPermissions(ArrayList<Flag> flags) throws URISyntaxException, FileNotFoundException, IOException
	{
		URL url = EmpiricalDataReader.class.getResource("/collision-permissions.tsv");
		if (url == null) throw new FileNotFoundException("Could not find collision-permissions.tsv");
		
		ArrayList<CollisionPermission> perms = new ArrayList<>();
		
		try (BufferedReader reader = new BufferedReader(new FileReader(new File(url.toURI()))))
		{
			if (!reader.ready()) throw new IOException("The file could not be read or was empty");
			ArrayList<String> headers = new ArrayList<>(Arrays.asList(reader.readLine().split("\t")));
			
			while (reader.ready())
			{
				String line = reader.readLine();
				String[] args = line.split("\t");
				
				CollisionPermission perm = new CollisionPermission();
				perm.setName(args[headers.indexOf("name")]);
				perm.setAllowed(!args[headers.indexOf("allowed")].equals("0"));
				
				if (args.length > 2)
				{
					ArrayList<String> flagNames = new ArrayList<>(Arrays.asList(args[headers.indexOf("flags")].split(",")));
					for (Flag flag : flags) if (flagNames.contains(flag.getName()))
					{
						flagNames.remove(flag.getName());
						perm.getFlags().add(flag);
					}
					
					if (!flagNames.isEmpty()) throw new IllegalArgumentException("Could not find a flag for the name \"" + flagNames.get(0) + "\"");
				}
				
				
				perms.add(perm);
			}
		}
		
		return perms;
	}
	
	public ArrayList<CollisionConstant> readCollisionConstants(ArrayList<CollisionPermission> perms) throws FileNotFoundException, IOException, URISyntaxException
	{
		URL url = EmpiricalDataReader.class.getResource("/collision-constants.tsv");
		if (url == null) throw new FileNotFoundException("Could not find collision-permissions.tsv");
		
		ArrayList<CollisionConstant> constants = new ArrayList<>();
		ArrayList<Direction> directions = new ArrayList<>(Arrays.asList(Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT));
		ArrayList<String> onPerms = new ArrayList<>(Arrays.asList("on up", "on down", "on left", "on right"));
		ArrayList<String> offPerms = new ArrayList<>(Arrays.asList("off up", "off down", "off left", "off right"));
		boolean[] steps = {true, false};
		
		try (BufferedReader reader = new BufferedReader(new FileReader(new File(url.toURI()))))
		{
			if (!reader.ready()) throw new IOException("The file could not be read or was empty");
			ArrayList<String> headers = new ArrayList<>(Arrays.asList(reader.readLine().split("\t")));
			
			while (reader.ready())
			{
				String line = reader.readLine();
				String[] args = line.split("\t");
				
				CollisionConstant constant = new CollisionConstant();
				constant.setName(args[headers.indexOf("name")]);
				constant.setValue(Integer.parseInt(args[headers.indexOf("hex")], 16));
				
				for (int i = 0; i < directions.size(); i++) if (headers.indexOf(onPerms.get(i)) < args.length && headers.indexOf(offPerms.get(i)) < args.length)
				{
					String[] permNames = {args[headers.indexOf(onPerms.get(i))], args[headers.indexOf(offPerms.get(i))]};
					for (int j = 0; j < 2; j++) for (CollisionPermission perm : perms) if (perm.getName().equals(permNames[j]))
					{
						constant.setPermissionsForStep(directions.get(i), steps[j], perm);
						break;
					}
				}
				
				constants.add(constant);
			}
		}
		
		return constants;
	}
	
}
